import type { AuthContext } from "../auth/index.mjs";
import { FileSystemPersistence } from "./persist.mjs";
import type { Metadata, ThreadStatus, RunStatus, MultitaskStrategy, OnConflictBehavior, IfNotExists, RunnableConfig, Assistant, RunKwargs, Run, Store, Message, Thread, CheckpointPayload, Ops, AssistantsRepo, RunsRepo, RunsStreamRepo, ThreadsRepo, ThreadsStateRepo } from "./types.mjs";
export declare class FileSystemOps implements Ops {
    private readonly conn;
    readonly assistants: FileSystemAssistants;
    readonly runs: FileSystemRuns;
    readonly threads: FileSystemThreads;
    constructor(conn: FileSystemPersistence<Store>);
    truncate(flags: {
        runs?: boolean;
        threads?: boolean;
        assistants?: boolean;
        checkpointer?: boolean;
        store?: boolean;
    }): Promise<void>;
}
declare class Queue {
    private log;
    private listeners;
    private nextId;
    private resumable;
    constructor(options: {
        resumable: boolean;
    });
    push(item: Message): void;
    get(options: {
        timeout: number;
        lastEventId?: string;
        signal?: AbortSignal;
    }): Promise<[id: string, message: Message]>;
}
declare class CancellationAbortController extends AbortController {
    abort(reason: "rollback" | "interrupt"): void;
}
declare class StreamManagerImpl {
    readers: Record<string, Queue>;
    control: Record<string, CancellationAbortController>;
    getQueue(runId: string, options: {
        ifNotFound: "create";
        resumable: boolean;
    }): Queue;
    getControl(runId: string): CancellationAbortController | undefined;
    isLocked(runId: string): boolean;
    lock(runId: string): AbortSignal;
    unlock(runId: string): void;
}
export declare const StreamManager: StreamManagerImpl;
export declare class FileSystemAssistants implements AssistantsRepo {
    private readonly conn;
    constructor(conn: FileSystemPersistence<Store>);
    search(options: {
        graph_id?: string;
        name?: string;
        metadata?: Metadata;
        limit: number;
        offset: number;
    }, auth: AuthContext | undefined): AsyncGenerator<{
        assistant: Assistant;
        total: number;
    }>;
    get(assistant_id: string, auth: AuthContext | undefined): Promise<Assistant>;
    put(assistant_id: string, options: {
        config: RunnableConfig;
        context: unknown;
        graph_id: string;
        metadata?: Metadata;
        if_exists: OnConflictBehavior;
        name?: string;
        description?: string;
    }, auth: AuthContext | undefined): Promise<Assistant>;
    patch(assistantId: string, options: {
        config?: RunnableConfig;
        context?: unknown;
        graph_id?: string;
        metadata?: Metadata;
        name?: string;
        description?: string;
    }, auth: AuthContext | undefined): Promise<Assistant>;
    delete(assistant_id: string, auth: AuthContext | undefined): Promise<string[]>;
    setLatest(assistant_id: string, version: number, auth: AuthContext | undefined): Promise<Assistant>;
    getVersions(assistant_id: string, options: {
        limit: number;
        offset: number;
        metadata?: Metadata;
    }, auth: AuthContext | undefined): Promise<import("./types.mjs").AssistantVersion[]>;
    count(options: {
        graph_id?: string;
        name?: string;
        metadata?: Metadata;
    }, auth: AuthContext | undefined): Promise<number>;
}
export declare class FileSystemThreads implements ThreadsRepo {
    private readonly conn;
    readonly state: ThreadsStateRepo;
    constructor(conn: FileSystemPersistence<Store>);
    search(options: {
        metadata?: Metadata;
        ids?: string[];
        status?: ThreadStatus;
        values?: Record<string, unknown>;
        limit: number;
        offset: number;
        sort_by?: "thread_id" | "status" | "created_at" | "updated_at";
        sort_order?: "asc" | "desc";
    }, auth: AuthContext | undefined): AsyncGenerator<{
        thread: Thread;
        total: number;
    }>;
    get(thread_id: string, auth: AuthContext | undefined): Promise<Thread>;
    put(thread_id: string, options: {
        metadata?: Metadata;
        if_exists: OnConflictBehavior;
    }, auth: AuthContext | undefined): Promise<Thread>;
    patch(threadId: string, options: {
        metadata?: Metadata;
    }, auth: AuthContext | undefined): Promise<Thread>;
    setStatus(threadId: string, options: {
        checkpoint?: CheckpointPayload;
        exception?: Error;
    }): Promise<void>;
    delete(thread_id: string, auth: AuthContext | undefined): Promise<string[]>;
    copy(thread_id: string, auth: AuthContext | undefined): Promise<Thread>;
    count(options: {
        metadata?: Metadata;
        values?: Record<string, unknown>;
        status?: ThreadStatus;
    }, auth: AuthContext | undefined): Promise<number>;
    private static State;
}
export declare class FileSystemRuns implements RunsRepo {
    private readonly conn;
    private readonly threads;
    readonly stream: RunsStreamRepo;
    constructor(conn: FileSystemPersistence<Store>);
    next(): AsyncGenerator<{
        run: Run;
        attempt: number;
        signal: AbortSignal;
    }>;
    put(runId: string, assistantId: string, kwargs: RunKwargs, options: {
        threadId?: string;
        userId?: string;
        status?: RunStatus;
        metadata?: Metadata;
        preventInsertInInflight?: boolean;
        multitaskStrategy?: MultitaskStrategy;
        ifNotExists?: IfNotExists;
        afterSeconds?: number;
    }, auth: AuthContext | undefined): Promise<Run[]>;
    get(runId: string, thread_id: string | undefined, auth: AuthContext | undefined): Promise<Run | null>;
    delete(run_id: string, thread_id: string | undefined, auth: AuthContext | undefined): Promise<string | null>;
    wait(runId: string, threadId: string | undefined, auth: AuthContext | undefined): Promise<unknown>;
    join(runId: string, threadId: string, auth: AuthContext | undefined): Promise<{} | null>;
    cancel(threadId: string | undefined, runIds: string[], options: {
        action?: "interrupt" | "rollback";
    }, auth: AuthContext | undefined): Promise<void>;
    search(threadId: string, options: {
        limit?: number | null;
        offset?: number | null;
        status?: string | null;
        metadata?: Metadata | null;
    }, auth: AuthContext | undefined): Promise<Run[]>;
    setStatus(runId: string, status: RunStatus): Promise<void>;
    private static Stream;
}
export declare class Crons {
}
export {};
