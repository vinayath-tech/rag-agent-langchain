import * as path from "node:path";
import * as fs from "node:fs/promises";
import * as superjson from "superjson";
import * as importMap from "./importMap.mjs";
import { load } from "@langchain/core/load";
// Add custom transformers for Uint8Array
superjson.registerCustom({
    isApplicable: (v) => v instanceof Uint8Array,
    serialize: (v) => Buffer.from(v).toString("base64"),
    deserialize: (v) => new Uint8Array(Buffer.from(v, "base64")),
}, "Uint8Array");
export function serialize(data) {
    return superjson.stringify(data);
}
export async function deserialize(input) {
    const result = await load(input, { importMap });
    return superjson.deserialize(result);
}
export class FileSystemPersistence {
    filepath = null;
    data = null;
    defaultSchema;
    name;
    flushTimeout = undefined;
    constructor(name, defaultSchema) {
        this.name = name;
        this.defaultSchema = defaultSchema;
    }
    async initialize(cwd) {
        this.filepath = path.resolve(cwd, ".langgraph_api", `${this.name}`);
        try {
            this.data = await deserialize(await fs.readFile(this.filepath, "utf-8"));
        }
        catch {
            this.data = this.defaultSchema();
        }
        await fs
            .mkdir(path.dirname(this.filepath), { recursive: true })
            .catch(() => void 0);
        return this;
    }
    async persist() {
        if (this.data == null || this.filepath == null)
            return;
        clearTimeout(this.flushTimeout);
        await fs.writeFile(this.filepath, serialize(this.data), "utf-8");
    }
    schedulePersist() {
        clearTimeout(this.flushTimeout);
        this.flushTimeout = setTimeout(() => this.persist(), 3000);
    }
    async flush() {
        await this.persist();
    }
    async with(fn) {
        if (this.filepath == null || this.data == null) {
            throw new Error(`${this.name} not initialized`);
        }
        try {
            return await fn(this.data);
        }
        finally {
            this.schedulePersist();
        }
    }
    async *withGenerator(fn) {
        if (this.filepath == null || this.data == null) {
            throw new Error(`${this.name} not initialized`);
        }
        let shouldPersist = false;
        let schedulePersist = () => void (shouldPersist = true);
        try {
            const gen = typeof fn === "function" ? fn(this.data, { schedulePersist }) : fn;
            yield* gen;
        }
        finally {
            if (shouldPersist)
                this.schedulePersist();
        }
    }
}
