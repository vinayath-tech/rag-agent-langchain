import * as uuid from "uuid";
import * as path from "node:path";
import * as fs from "node:fs/promises";
import { pathToFileURL } from "node:url";
export const GRAPHS = {};
export const NAMESPACE_GRAPH = uuid.parse("6ba7b821-9dad-11d1-80b4-00c04fd430c8");
export async function resolveGraph(spec, options) {
    const [userFile, exportSymbol] = spec.split(":", 2);
    const sourceFile = path.resolve(options.cwd, userFile);
    // validate file exists
    await fs.stat(sourceFile);
    if (options?.onlyFilePresence) {
        return { sourceFile, exportSymbol, resolved: undefined };
    }
    const isGraph = (graph) => {
        if (typeof graph !== "object" || graph == null)
            return false;
        return "compile" in graph && typeof graph.compile === "function";
    };
    const isCompiledGraph = (graph) => {
        if (typeof graph !== "object" || graph == null)
            return false;
        return ("builder" in graph &&
            typeof graph.builder === "object" &&
            graph.builder != null);
    };
    const graph = await import(pathToFileURL(sourceFile).toString()).then((module) => module[exportSymbol || "default"]);
    // obtain the graph, and if not compiled, compile it
    const resolved = await (async () => {
        if (!graph)
            throw new Error("Failed to load graph: graph is nullush");
        const afterResolve = (graphLike) => {
            const graph = isGraph(graphLike) ? graphLike.compile() : graphLike;
            // TODO: hack, remove once LangChain 1.x createAgent is fixed
            if (!isCompiledGraph(graph) && "graph" in graph) {
                return graph.graph;
            }
            return graph;
        };
        if (typeof graph === "function") {
            return async (config) => {
                const graphLike = await graph(config);
                return afterResolve(graphLike);
            };
        }
        return afterResolve(await graph);
    })();
    return { sourceFile, exportSymbol, resolved };
}
